{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///D:/WorkSpace/lovebee/node_modules/.pnpm/framer-motion%4012.14.0_react_dab1f5af845d60c833aadcb3a090901f/node_modules/framer-motion/dist/es/animation/hooks/animation-controls.mjs"],"sourcesContent":["import { invariant } from 'motion-utils';\nimport { setTarget } from '../../render/utils/setters.mjs';\nimport { animateVisualElement } from '../interfaces/visual-element.mjs';\n\nfunction stopAnimation(visualElement) {\n    visualElement.values.forEach((value) => value.stop());\n}\nfunction setVariants(visualElement, variantLabels) {\n    const reversedLabels = [...variantLabels].reverse();\n    reversedLabels.forEach((key) => {\n        const variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        if (visualElement.variantChildren) {\n            visualElement.variantChildren.forEach((child) => {\n                setVariants(child, variantLabels);\n            });\n        }\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    let hasMounted = false;\n    /**\n     * A collection of linked component animation controls.\n     */\n    const subscribers = new Set();\n    const controls = {\n        subscribe(visualElement) {\n            subscribers.add(visualElement);\n            return () => void subscribers.delete(visualElement);\n        },\n        start(definition, transitionOverride) {\n            invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            const animations = [];\n            subscribers.forEach((visualElement) => {\n                animations.push(animateVisualElement(visualElement, definition, {\n                    transitionOverride,\n                }));\n            });\n            return Promise.all(animations);\n        },\n        set(definition) {\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach((visualElement) => {\n                setValues(visualElement, definition);\n            });\n        },\n        stop() {\n            subscribers.forEach((visualElement) => {\n                stopAnimation(visualElement);\n            });\n        },\n        mount() {\n            hasMounted = true;\n            return () => {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\nexport { animationControls, setValues };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,SAAS,cAAc,aAAa;IAChC,cAAc,MAAM,CAAC,OAAO,CAAC,CAAC,QAAU,MAAM,IAAI;AACtD;AACA,SAAS,YAAY,aAAa,EAAE,aAAa;IAC7C,MAAM,iBAAiB;WAAI;KAAc,CAAC,OAAO;IACjD,eAAe,OAAO,CAAC,CAAC;QACpB,MAAM,UAAU,cAAc,UAAU,CAAC;QACzC,WAAW,CAAA,GAAA,sRAAA,CAAA,YAAS,AAAD,EAAE,eAAe;QACpC,IAAI,cAAc,eAAe,EAAE;YAC/B,cAAc,eAAe,CAAC,OAAO,CAAC,CAAC;gBACnC,YAAY,OAAO;YACvB;QACJ;IACJ;AACJ;AACA,SAAS,UAAU,aAAa,EAAE,UAAU;IACxC,IAAI,MAAM,OAAO,CAAC,aAAa;QAC3B,OAAO,YAAY,eAAe;IACtC,OACK,IAAI,OAAO,eAAe,UAAU;QACrC,OAAO,YAAY,eAAe;YAAC;SAAW;IAClD,OACK;QACD,CAAA,GAAA,sRAAA,CAAA,YAAS,AAAD,EAAE,eAAe;IAC7B;AACJ;AACA;;CAEC,GACD,SAAS;IACL;;KAEC,GACD,IAAI,aAAa;IACjB;;KAEC,GACD,MAAM,cAAc,IAAI;IACxB,MAAM,WAAW;QACb,WAAU,aAAa;YACnB,YAAY,GAAG,CAAC;YAChB,OAAO,IAAM,KAAK,YAAY,MAAM,CAAC;QACzC;QACA,OAAM,UAAU,EAAE,kBAAkB;YAChC,CAAA,GAAA,yNAAA,CAAA,YAAS,AAAD,EAAE,YAAY;YACtB,MAAM,aAAa,EAAE;YACrB,YAAY,OAAO,CAAC,CAAC;gBACjB,WAAW,IAAI,CAAC,CAAA,GAAA,wSAAA,CAAA,uBAAoB,AAAD,EAAE,eAAe,YAAY;oBAC5D;gBACJ;YACJ;YACA,OAAO,QAAQ,GAAG,CAAC;QACvB;QACA,KAAI,UAAU;YACV,CAAA,GAAA,yNAAA,CAAA,YAAS,AAAD,EAAE,YAAY;YACtB,OAAO,YAAY,OAAO,CAAC,CAAC;gBACxB,UAAU,eAAe;YAC7B;QACJ;QACA;YACI,YAAY,OAAO,CAAC,CAAC;gBACjB,cAAc;YAClB;QACJ;QACA;YACI,aAAa;YACb,OAAO;gBACH,aAAa;gBACb,SAAS,IAAI;YACjB;QACJ;IACJ;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 97, "column": 0}, "map": {"version":3,"sources":["file:///D:/WorkSpace/lovebee/node_modules/.pnpm/framer-motion%4012.14.0_react_dab1f5af845d60c833aadcb3a090901f/node_modules/framer-motion/dist/es/animation/hooks/use-animation.mjs"],"sourcesContent":["import { animationControls } from './animation-controls.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimationControls() {\n    const controls = useConstant(animationControls);\n    useIsomorphicLayoutEffect(controls.mount, []);\n    return controls;\n}\nconst useAnimation = useAnimationControls;\n\nexport { useAnimation, useAnimationControls };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BC,GACD,SAAS;IACL,MAAM,WAAW,CAAA,GAAA,oRAAA,CAAA,cAAW,AAAD,EAAE,uSAAA,CAAA,oBAAiB;IAC9C,CAAA,GAAA,gSAAA,CAAA,4BAAyB,AAAD,EAAE,SAAS,KAAK,EAAE,EAAE;IAC5C,OAAO;AACX;AACA,MAAM,eAAe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///D:/WorkSpace/lovebee/node_modules/.pnpm/framer-motion%4012.14.0_react_dab1f5af845d60c833aadcb3a090901f/node_modules/framer-motion/dist/es/utils/reduced-motion/use-reduced-motion.mjs"],"sourcesContent":["import { warnOnce } from 'motion-utils';\nimport { useState } from 'react';\nimport { initPrefersReducedMotion } from './index.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from './state.mjs';\n\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\nfunction useReducedMotion() {\n    /**\n     * Lazy initialisation of prefersReducedMotion\n     */\n    !hasReducedMotionListener.current && initPrefersReducedMotion();\n    const [shouldReduceMotion] = useState(prefersReducedMotion.current);\n    if (process.env.NODE_ENV !== \"production\") {\n        warnOnce(shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n    }\n    /**\n     * TODO See if people miss automatically updating shouldReduceMotion setting\n     */\n    return shouldReduceMotion;\n}\n\nexport { useReducedMotion };\n"],"names":[],"mappings":";;;AAqCQ;AArCR;AACA;AACA;AACA;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;CAyBC,GACD,SAAS;IACL;;KAEC,GACD,CAAC,+RAAA,CAAA,2BAAwB,CAAC,OAAO,IAAI,CAAA,GAAA,+RAAA,CAAA,2BAAwB,AAAD;IAC5D,MAAM,CAAC,mBAAmB,GAAG,CAAA,GAAA,4RAAA,CAAA,WAAQ,AAAD,EAAE,+RAAA,CAAA,uBAAoB,CAAC,OAAO;IAClE,wCAA2C;QACvC,CAAA,GAAA,+NAAA,CAAA,WAAQ,AAAD,EAAE,uBAAuB,MAAM;IAC1C;IACA;;KAEC,GACD,OAAO;AACX","ignoreList":[0],"debugId":null}}]
}